<!doctype html><html lang="en">

<head>
<title>tcheckovsky</title>
<meta name="viewport"
content="width=device-width, initial-scale=1.0">
<style id="demoStyles">

@font-face {
    font-family : luckiest;
    src : url(luckiest.ttf);
}

* {
    box-sizing: border-box;
    word-wrap: break-word;
}

body {
    
    --nose-hsla: hsla(20, 40%, 100%, 0);
    --nose-h: 20;
    --nose-s: 40%;
    --nose-l: 100%;
    --nose-a: 0;
    
    padding: 0;
    margin: 0;
    height: 100%;
    overflow: hidden;
    background-color: #666;
    font-size: 22px;
    text-align: justify;
    hyphens: auto;
        
    --lightness: hsl(
        var(--nose-h),
        var(--nose-s),
        var(--nose-l)
    );
    
    --midness: hsl(
        var(--nose-h),
        calc(0.5 * var(--nose-s)),
        calc(0.5 * var(--nose-l))
    );
    
    --darkness: hsl(
        var(--nose-h),
        var(--nose-s),
        calc(0.35 * var(--nose-l))
    );
    
    --blackness: hsl(
        var(--nose-h),
        var(--nose-s),
        calc(0.20 * var(--nose-l))
    );
                
    --main-color: var(--lightness);
    --greyed-out: var(--darkness);
    --back-color: #666;
    --holder-back: #111;
    
    --trans-speed: 0.3s;

    /* !!!MUST have spaces between -'s !!!
    calc((var(--nose-l) - 30%)/(.8 - .3)) */
    
}

.holder {
	position: relative;
    color: var(--main-color);
    background-color: var(--holder-back);
    margin: auto;
    width: 100%;
    max-width: 700px;
    user-select: none;
    touch-action: none;
}

a {
    text-decoration: none;
    color: var(--darkness);
}

a:hover, a:visited {
    transition: color linear var(--trans-speed);
    color: var(--darkness);
}

.qa > div > a, .qa > div  > a,
.qb > div > a, .qb > div  > a,
.qa > div > a:hover, .qa > div  > a:visited,
.qb > div > a:hover, .qb > div> a:visited
{
    color: var(--lightness);
}

.qr > b {
    color: var(--darkness);
}

.qa > div > b,
.qb > div > b {
    color: var(--lightness);
}

pre {
    background-color: var(--midness);
    margin: 0px;
    padding: 10px;
    color: var(--lightness);
    overflow: auto;
}

hr {
    border-top: 1px solid var(--blackness);
    border-bottom: none;
    border-left: none;
    border-right: none;
    margin: 7px 0px 7px 0px;
}

.qr {
    padding: 10px;
}

.qa:after {
    content: "";
    display: table;
    clear: both;
}

.qa > div {
    float: left;
    padding: 10px;
    height: auto;
}

.qa > div:nth-child(1) {
  width: 65%;
}

.qa > div:nth-child(2) {
  width: 35%;
}

.qb:after {
    content: "";
    display: table;
    clear: both;
}

.qb > div {
    float: left;
    padding: 10px;
    height: auto;
}

.qb > div:nth-child(1) {
  width: 35%;
}

.qb > div:nth-child(2) {
  width: 65%;
}

.qa, .qb {
    color: var(--midness);
}

.mobr {
    display: none;
}

.hobr {
    display: inline-block;
}

.abhr {
    display: none;
}

/*possibly a portrait mobi-fone*/
@media screen and (max-width:500px) {

	.qa > div:nth-child(1),
	.qa > div:nth-child(2),
	.qb > div:nth-child(1),
	.qb > div:nth-child(2)
	{
    	width: 100%;
    }
    
    .mobr {
        display: inline-block;
    }
    .hobr {
        display: none;
    }
    .abhr {
        display: block;
    }
    ul {
        text-align: left;
    }
    
    #title {
        font-size: 20px;
    }

}

/*possibly a mobile landscraper*/
@media screen and (orientation: landscape) and (max-width: 760px) {
    
}

.signature {
    text-align: right;
    font-family: 'luckiest';
    font-style: italic;
    height: 200px;
    -webkit-text-stroke: 1px var(--darkness);
    color: var(--midness);
    user-select: none;
}


</style>
<style id="czechStyles">

#title {
    font-family: luckiest;
    font-size: 40px;
    text-align: center;
    -webkit-text-stroke: 2px var(--darkness);
    color: var(--midness);
    transition: font-size ease-in 1500ms;
}

[data-czech] {
    position: relative;
    height: 52px;
    padding-left: 68px;
    margin-top: 20px;
    width: 100%;
    user-select: none;
}

svg {
    --linesize: 4px;
    position: absolute;
    top: 0px;
    left: 0px;
    height: 50px;
    width: 50px;
    display: block;
    float: left;
    z-index: 200;
    isolation: isolate;
    overflow: visible;
    padding: 0;
    margin: 0;
    pointer-events: none;
}

path {
    xfill: none;
    fill: var(--lightness, #f0f);
    xstroke: none;
    xstroke-width: var(--linesize);
    xstroke-linecap: round;
    xstroke: var(--lightness, #f0f);
    transition: opacity linear 400ms;
}

#pad > path {
    xstroke: none;
    xfill: url(#svgGrad);
    stroke-width: 1;
    stroke: var(--lightness);
    fill: var(--lightness);
}

#ratPath {
    stroke: var(--lightness);
    stroke-width: 0.2px;
    fill: none;
    marker-start: url(#dot);
    marker-mid: url(#dot);
    marker-end: url(#dot);
}

.ratLips {
    fill: var(--darkness);
    stroke: var(--midness);
    stroke-width: 10px;
}

#ratLine {
    fill: none;
    --xdotdot-color: #ea0;
    stroke: rgba(255,0,2,0.5):
    --xlinesize: 5px;
    stroke-width: 5px;
    marker-start: url(#dotQ);
    marker-mid: url(#dotQ);
    marker-end: url(#dotQ);
}

#addInput {
    height:50px;
    min-width: 0;
    font-size: 100%;
    font-style: italic;
    color: var(--lightness);
    background-color: var(--darkness);
    flex: 0 1 calc(100% - 80px);
    margin-right: 10px;
}

#addInput::placeholder {
    
    text-align: center;
    font-style: italic;
    color: #fff;
    opacity: 0.25;
    
}

#addBox {
    padding: 0px;
    margin: 0px;
    border: none;
    height: 50px;
    width: 80px;
    font-family: luckiest;
    -webkit-text-stroke: 2px var(--midness);
    color: var(--blackness);
    background-color: var(--darkness);
    line-height: 60px;
    font-size: 50px;
    flex: 0 0 80px;
    min-width: 0;
}

.box {
    position: absolute;
    top: 0;
    left: 0;
    height: 50px;
    width: 50px;
    margin-left:10px;
    border: 1px solid var(--darkness);
    background-color: var(--midness);
    transition: all linear 400ms;
}

.completed {
    position: absolute;
    top: 0;
    left: 0;
    height: 50px;
    width: 50px;
    border-radius: 50%;
    border: 1px solid var(--darkness);
    background-color: var(--blackness);
    transform: rotate(-360deg);
    text-align: center;
    font-size: 20px;
    line-height: 50px;
}

.box > svg {
    position: absolute;
    top: 0px;
    left: 0px;
    background-color: none"
    overflow: visible;
}

.box > svg > path {
    
    d:path('M 14 17 L 22 33 Q 27 10 38 -8 L 44 2 Q 32 15.25 23.25 46 Q 14 37 9 27 Z');
    
    vector-effect: non-scaling-stroke;
    stroke-width: 5px;
    stroke: var(--lightness);
    stroke-linecap: round;
    fill: none;
    stroke: none;
    fill: var(--lightness);
    opacity: 0;
    transition: opacity linear 400ms;
    
}

.titleArrow {
    display: inline-block;
    transform: rotate(0deg);
    xclip-path: polygon(0% 0%, 100% 0%, 50% 100%);
    xbackground-color: var(--lightness);
    height: 100%;
    text-align: center;
    font-size: 0.9em;
    xvertical-align: middle;
    xtransform-origin: 50% 50%;
    transition: transform linear 300ms;
    
}

#title:hover .titleArrow.left {
    transform: rotate( 180deg) translateY(5px);
}

#title:hover .titleArrow.rite {
    transform: rotate(-180deg) translateY(5px);
}

/*possibly a mobile landscraper*/
@media screen and (orientation: landscape) and (max-width: 760px) {

    
}
    
</style>
<!--script defer src="nanopicker.js"></script-->
</head>

<body>
<div id="hold0" class="holder">
    
    <div id="title" class="qr">
    <div class="titleArrow left"> &#9660; </div>
    tczekov
    <div class="titleArrow rite"> &#9660; </div>
    </div>
    
    <div id="notes" class="qr" style="
        font-size:20px;
        text-align:center;
        padding: 0;
    "> ...
    </div>
    
    <div>
    <div id="30" class="qr" data-czech="hrt">
    &nbsp;heart box:&nbsp;&nbsp;
    <b><i>&#9825;</i></b>&nbsp;</div>
        
    <div id="303" class="qr" data-czech="pls">
    &nbsp;plus sign:&nbsp;&nbsp;
    <b><i>&#43;</i></b>&nbsp;</div>
    
    </div>
    
    <br><hr><div class="qr signature">~queviva</div>
    
</div>
<div svgdiv ><svg viewbox="0 0 50 50">
    <defs>
        <marker id="dot" refX="10" refY="10"
         vector-effect="non-scaling-size"
         markerUnits="userSpaceOnUse"
         markerWidth="20"
         markerHeight="20"
         orient="auto"
        >
            <circle id="dotdot" cx="10" cy="10" r="1"
             vector-effect="non-scaling-size"
             fill="#c30"
             stroke="none"
            ></circle>
        </marker>
        <marker id="dotQ" refX="10" refY="10"
         vector-effect="non-scaling-size"
         markerUnits="userSpaceOnUse"
         markerWidth="20"
         markerHeight="20"
         orient="auto"
        >
            <circle id="dotdotQ" cx="10" cy="10" r="4"
             vector-effect="non-scaling-size"
             fill="#ea0"
             stroke="none"
            ></circle>
        </marker>
        <linearGradient id="svgGrad"
        gradientTransform="rotate(40)"
        >
        <stop offset="0%" stop-color="#c30" />
        <stop offset="80%" stop-color="#fb0" />
        </linearGradient>
    </defs>
    <g id="ratGroup" transform="translate(00 00)">
        <g id="lipGroup"></g>
        <path id="ratLine" stroke="#c30"
        stroke-width="5"/>
        <path id="ratPath" />
    </g>
    <g id="pad"></g>
</svg></div>
</body>

<script>
////////////////////////////////////////////////////////{
// pizzaface
//
const log = console.log;
const fix = (...v) => console.log(v.map(x =>
    typeof x === 'number' ? x.toFixed(1) :
    typeof x === 'string' ? x.replace(/([\d\.-]+)/g,m=>Number(m).toFixed(1)) : x
).join(' '));
const clog = (...v) => (
    notes.innerHTML += v +' ',
    console.log(...v), true);
////////////////////////////////////////////////////////}

new function() {
    
// prefs {

const prefs = {
    useDrawnMark : false,
    minSize : 10,
    maxSize : 150,
    penWidth : 8,
    penTheta : -0.46,   // radians
    pause : 1000,       // milliseconds
    rat: 'master'
};
    
//}

// constants {

const NS = 'http://www.w3.org/2000/svg';
const addLiz = document.addEventListener;
const remLiz = document.removeEventListener;
const svg = document.getElementById('pad');
let waiting = false;
let compList = [];
let coordList = [];
const pi180 = 180 / Math.PI, pi2 = Math.PI / 2;
const perc = v => Math.round(v*100) + '%';
const min = Math.min;
const max = Math.max;
const abs = Math.abs;
const cos = Math.cos;
const sin = Math.sin;
const tan = Math.tan;
const sqrt = Math.sqrt;
const sign = Math.sign;
const atan = Math.atan;
const rand = Math.random;
const atan2 = Math.atan2;

const xtra = cos(prefs.penTheta) * prefs.penWidth;
const ytra = sin(prefs.penTheta) * prefs.penWidth;


//}

// point object {

function Point (x, y) {

    this.x = x;
    this.y = y;

    this.RtoL = (x + xtra) + ' ' + (y + ytra) + 'L' +
                (x - xtra) + ' ' + (y - ytra);

    this.LtoR = (x - xtra) + ' ' + (y - ytra) + 'L' +
                (x + xtra) + ' ' + (y + ytra);

}

//}

// line object {
    
function LineObj (d, filt=true) {

    this.coor = [...d];
    
    let XXX = d.map(_ => _[0]);
    let YYY = d.map(_ => _[1]);

    if (filt) {
        
        this.coor = [
            [XXX[0], YYY[0]]
        ];
    
        XXX.slice(2, -1).forEach((_, i) => {
    
            if (
                XXX[i + 2] !== XXX[i + 1] &&
                YYY[i + 2] !== YYY[i + 1]
    
            ) {
                this.coor.push([XXX[i + 1], YYY[i + 1]]);
            }
    
        });
    
        this.coor.push([XXX.at(-1), YYY.at(-1)]);
    }

    this.XXX = this.coor.map(c => c[0]);
    this.YYY = this.coor.map(c => c[1]);
    this.xMin = min(...this.XXX);
    this.yMin = min(...this.YYY);
    this.xMax = max(...this.XXX);
    this.yMax = max(...this.YYY);
    this.wide = this.xMax - this.xMin;
    this.high = this.yMax - this.yMin;

}

LineObj.prototype.getTurns = function (filt=true) {

    this.turns = {};
    
    let T = [

        this.XXX.slice(1).map((x, i) =>
            [sign(x - this.XXX[i]), i]
        ).filter(v => v[0] !== 0),

        this.YYY.slice(1).map((y, i) =>
            [sign(y - this.YYY[i]), i]
        ).filter(v => v[0] !== 0)

    ];
    
    T = T.map(t =>
        t.slice(1).filter((v, i) => v[0] !== t[i][0])
    );
    
    T.forEach((t, i) => {
        
        this.turns[['xPts','yPts'][i]] = t.map(v =>
            [this.XXX[v[1]], this.YYY[v[1]], v[1]]
        );
        
        if (filt) {
            
            this.turns[['xPts', 'yPts'][i]] =
            this.turns[['xPts', 'yPts'][i]].filter(t => {
                return t[2] > 5 || (
                    abs(this.XXX[0] - t[0]) > 5 ||
                    abs(this.YYY[0] - t[1]) > 10
                )
            });
            
        }
        
        this.turns[['x','y'][i]] =
        this.turns[['xPts', 'yPts'][i]].length;
        
    });
    
    return this;

};

LineObj.prototype.getClocks = function () {
    
    this.clocks = this.XXX.slice(2).map((_, i) => {

        let val =
            (this.YYY[i + 1] - this.YYY[i]) *
            (this.XXX[i + 2] - this.XXX[i + 1]) -
            (this.XXX[i + 1] - this.XXX[i]) *
            (this.YYY[i + 2] - this.YYY[i + 1]);

        return val === 0 ? 0 : val > 0 ? 1 : -1

    });
    
    return this;

};

LineObj.prototype.getSlopes = function () {
    
    this.slopes = {
    
        val: this.XXX.slice(1).map((_, i) =>
            (this.YYY[i] - this.YYY[i + 1]) /
            (this.XXX[i] - this.XXX[i + 1])
            
        ),
    
        all: (this.YYY.at(-1) - this.YYY[0]) /
             (this.XXX.at(-1) - this.XXX[0])
    }
    
    this.slopes.ave = this.slopes.val.reduce((a,b)=>a+b,0)/
                      this.slopes.val.length;
    
    this.slopes.err = this.slopes.val.map(v =>
        abs(this.slopes.ave - v)
    );
    
    return this;
    
};

LineObj.prototype.getSelfXs = function () {

    this.crosses = [];
    
    this.coor.slice(1, -2).forEach((ci, i) => {
    this.coor.slice(i + 3).forEach((cj, j) => {
    
        let p = crss([this.coor[i],ci,this.coor[i+j+2],cj]);
        
        if (p) this.crosses.push(
            {id1: i, id2: i+j+2, x: p[0], y: p[1]}
        );
        
    
    })});
    
    return this;
    
};

LineObj.prototype.hasSelfXs = function () {

    let p = false;

    this.coor.slice(1, -2).some((ci, i) =>
    this.coor.slice(i + 3).some((cj, j) =>
        p = crss([this.coor[i], ci, this.coor[i + j + 2], cj])
    ));
    
    return p;

};

LineObj.prototype.getAtOrig = function (a=0, b=null) {

    let pts = this.coor.slice(a, b||this.coor.length);
    
    let ang = atan2(
        pts.at(-1)[1] - pts[0][1],
        pts.at(-1)[0] - pts[0][0]
    );
    
    let T = 1.57 - ang;
    
    let cosT = cos(T);
    let sinT = sin(T);

    pts = pts.map(d => [
        d[0] - pts[0][0],
        d[1] - pts[0][1]
    ]);

    pts = pts.map(d => [
        d[0] * cosT - d[1] * sinT,
        d[0] * sinT + d[1] * cosT
    ]);

    this.org = new LineObj(pts, false);
    this.org.ang = ang;
    this.org.len = pts.at(-1)[1];
    
    return this;

};

LineObj.prototype.getAtAngl = function (ang) {

    let pts = this.coor.slice(0);
    
    let T = pi2 - ang;
    
    let cosT = cos(T);
    let sinT = sin(T);

    pts = pts.map(d => [
        d[0] - pts[0][0],
        d[1] - pts[0][1]
    ]);

    pts = pts.map(d => [
        d[0] * cosT - d[1] * sinT,
        d[0] * sinT + d[1] * cosT
    ]);

    return new LineObj(pts, false);

};

LineObj.prototype.makeSVG = function () {
    
    this.svg = 'M'+ this.coor[0].join(' ');
        
    this.coor.slice(1).forEach((_, i) => {
        
        this.svg += 'L' + this.coor[i + 1].join(' ');
        
    });
    
    return this;
    
};

//}

// tczech object {

function Tczech (CZ) {
    
    this.CZ = CZ;
    this.divS = CZ.style;

    this.test = tests[CZ.dataset['czech'] || 'any'];

    this.completed = false;

    this.box = document.createElement('div');
    this.box.classList.add('box');
    this.box.innerHTML =
        `<svg viewbox="0 0 50 50"><path/></svg>`;

    this.svg = this.box.childNodes[0];
    this.check = this.svg.childNodes[0];

    CZ.appendChild(this.box);

}

Tczech.prototype.activate = function (v) {
    this.CZ[(v ? 'add' : 'remove') + 'EventListener'](
        'pointermove', this.comp.bind(this), { once: true }
    );
};

Tczech.prototype.comp = function (e) {
        this.activate(false);
        this.completed = true;
        compList.push(this);
};

Tczech.prototype.reprep = function () {

    this.CZ.addEventListener('dblclick', e => {

        this.completed = false;
        this.box.classList.remove('completed');
        this.divS.textDecoration = 'none';
        this.check.style.opacity = 0;

        waiting = clearTimeout(waiting);

    }, { once: true });

};

//}

// test methods {

const tests = {
    
    // {

    // {} nothing at all
    nun: d => false,
    
    // *  anything at all
    any: d => true,
    
    // | up stroke
    ups: d => {
        
        let L;
        
        return (
            
            d.length === 1 &&
            
            (L = linz(d, 0)[0].getTurns().getAtOrig()) &&
            
            L.wide < 10 &&
            L.high > 20 && L.high < 2 * prefs.maxSize &&
            L.turns.x === 0 && L.turns.y === 0 &&
            L.org.ang < -1.3 && L.org.ang > -1.84
            
        );
        
    },
         
    // | dn stroke
    dns: d => {
        
        let L;
        
        return (
            
            d.length === 1 &&
            (L = linz(d, 0)[0].getTurns().getAtOrig()) &&
            L.wide < 10 &&
            L.high > 20 && L.high < 2 * prefs.maxSize &&
            L.turns.x === 0 && L.turns.y === 0 &&
            L.org.ang > 1.3 && L.org.ang < 1.84
            
        );
        
    },
        
    // _ underline
    und: d => {
                
        let L;
        
        return (
            
            d.length === 1 &&
            (L = linz(d)[0].getTurns()) &&
            L.wide > 20 && L.wide < 2 * prefs.maxSize &&
            L.high < 0.1 * L.wide &&
            L.turns.x === 0 && L.turns.y < 2
            
        );
        
    },
    
    // / slash
    sla: d => {
        
        let L;
        
        return (
            
            d.length === 1 &&
            
            (L = linz(d)[0].getTurns().getSlopes()) &&
            
            L.wide > prefs.minSize &&
            L.wide < prefs.maxSize &&
            L.high > prefs.minSize &&
            L.high < prefs.maxSize &&
            
            L.turns.x === 0 &&
            L.turns.y === 0 &&
            
            L.slopes.val.every(s => -3 < s && s < -0.3)
             
        );

    },
    
    // two lines cross &#215;
    crs: d => {
        
        let L;
        
        return (
            d.length === 2 &&
            (L = linz(d)) &&
            L[0].coor.slice(1).some((ci, i) =>
            L[1].coor.slice(1).some((cj, j) =>
                crss([L[0].coor[i], ci, L[1].coor[j], cj])
            ))
        );

    },

    // remove-werd loop
    lup: d => {
        
        let L;
        
        return (
            
            d.length === 1 &&
            
            (L = linz(d)[0].getTurns().getSelfXs()) &&
            
            L.turns.x === 2 &&
            L.turns.y === 1 &&
            L.crosses.length === 1 &&
            
            L.wide > prefs.minSize &&
            L.wide < prefs.maxSize &&
            L.high > prefs.minSize &&
            L.high < prefs.maxSize &&
        
            abs(L.XXX[0] - L.xMin) < 0.01 * L.high &&
        
            L.YYY.at(-1) < L.YYY[0] &&
        
            L.crosses[0].x - L.XXX[0] > 0.5 * L.wide &&
            L.YYY[0] - L.crosses[0].y > 0.5 * L.high &&
        
            L.turns.yPts[0][1] < L.turns.xPts[0][1]
        
        );
        
    },
    
    // multiple tests
    mul: d => {

        let T = Object.fromEntries(`
        
        tri xix crs scr pls und
        
        `.trim().split(/\s+/).map((v, i) =>
            [v, tests[v](d.slice(0, [3,2,2,1,2,1][i]))]
        ));
        
        return(Object.values(T).every(v => v));
        
    },

    // check box &#10003;
    chx: d => {
        
        let L, Dn, Up;
        
        return (
            
            d.length === 1 &&
            
            (d[0].at(-1)[0] > d[0][0][0] || d[0].reverse()) &&
            
            (L = linz(d)[0].getTurns()) &&
            
            L.turns.x < 2 && L.turns.y === 1 &&
                    
            L.wide > prefs.minSize &&
            L.wide < prefs.maxSize &&
            L.high > prefs.minSize &&
            L.high < prefs.maxSize &&
            
            (Dn = {
                ...L.getAtOrig(0, L.turns.yPts[0][2] + 1).org
            },
            Up = {
                ...L.getAtOrig(L.turns.yPts[0][2]).org
            }, true ) &&

            Up.len > 1.6 * Dn.len &&
            
            L.turns.yPts[0][1] - L.YYY[0] > 0.2 * L.high &&
            
            Dn.coor.every(p => -3 < p[0] && p[0] < 5) &&
        
            Up.coor.every(p => -3 < p[0] && p[0] < 10) &&
            
            Dn.ang - Up.ang > 1.5

        );

    },
        
    // infinity symbol &#8734;
    inf: d => {
        
        let L;
        
        return (
            
            d.length === 1 &&
            
            (L = linz(d)[0].getSelfXs().getTurns()) &&
            
            L.wide > 40 && L.wide < 2 * prefs.maxSize &&
            
            (L.crosses = L.crosses.filter(p =>
                abs(p.x - L.xMin - L.wide / 2) < 0.1 * L.wide
            )) &&
    
            0 < L.crosses.length && L.crosses.length < 3 &&
            
            abs((
                L.YYY[L.XXX.indexOf(L.xMax)] -
                L.YYY[L.XXX.indexOf(L.xMin)]) / L.wide
            ) < 0.2 &&
            
            //abs(L.XXX[0] - L.XXX.at(-1)) < 10 &&
            //abs(L.YYY[0] - L.YYY.at(-1)) < 10 &&
            
            0 < L.turns.x && L.turns.x < 3 &&
            2 < L.turns.y && L.turns.y < 5
            
        );
    
    },

    // triple underline &#8801;
    tri : d => {
        
        let L;
        
        return (
            
            d.length === 3 &&
            
            (L = linz(d).sort((a, b) => a.yMax - b.yMax)) &&
            
            L[2].yMax - L[0].yMin < prefs.maxSize &&
            
            L.every((LL, i) => ( LL.getTurns(),
                
                    LL.turns.x === 0 &&
                    LL.turns.y < 2 &&
                    LL.wide > prefs.minSize &&
                    LL.wide < prefs.maxSize &&
                    LL.high < 0.5 * LL.wide
                    
            )) &&
            
            L.slice(1).every((LL, i) => (
                
                    abs(L[0].xMin - LL.xMin)
                    < 0.6 * L[0].wide &&
                    
                    abs(L[0].xMax - LL.xMax)
                    < 0.6 * L[0].wide &&
                    
                    LL.yMax - L[0].yMax
                    > i * prefs.penWidth
                    
            )) &&
            
            !hitt(L[0], L[1]) &&
            !hitt(L[0], L[2]) &&
            !hitt(L[1], L[2])
            
            
        );
        
    },

    // # mark
    has: d => {
        
        let Vt, Hz;
        
        return (
            
            d.length === 4 &&
            
            ([Vt, Hz] = linz(d).reduce((acc, LL) => {
            
                LL.getTurns();
                acc[(
                    
                   (LL.turns.y === 0 &&
                    LL.turns.x < 2 &&
                    LL.XXX.every(x => abs(LL.XXX[0]-x) < 20))
                    ? 0 :
            
                   (LL.turns.x === 0 &&
                    LL.turns.y < 2 &&
                    LL.YYY.every(y => abs(LL.YYY[0]-y) < 20))
                    ? 1 : 2
                
                )].push(LL);
            
                return acc;
                
            },[[],[],[]])) &&
            
            Vt.length === 2 && Hz.length === 2 &&
            
            (Hz.wide = abs(
                max(Hz[0].xMax, Hz[1].xMax) -
                min(Hz[0].xMin, Hz[1].xMin)
            ),Vt.high = abs(
                max(Vt[0].yMax, Vt[1].yMax) -
                min(Vt[0].yMin, Vt[1].yMin)
            )) &&
            
            Hz.wide > prefs.minSize &&
            Hz.wide < prefs.maxSize &&
            Vt.high > prefs.minSize &&
            Vt.high < prefs.maxSize &&
            
            hitt(Hz[0], Vt[0]) &&
            hitt(Hz[0], Vt[1]) &&
            hitt(Hz[1], Vt[0]) &&
            hitt(Hz[1], Vt[1]) &&
            
            abs(Hz[0].yMax - Hz[1].yMax) > prefs.penWidth &&
            abs(Vt[0].xMax - Vt[1].xMax) > prefs.penWidth
            
        );
        
    },
    
    // * five point &#9957;
    str: d => {
        
        let L;
        
        return (
            
            d.length === 1 &&
            
            (L = linz(d)[0].getTurns().getSelfXs()) &&
            
            L.wide < 2 * prefs.maxSize &&
            L.high < 2 * prefs.maxSize &&
            
            ((
                L.turns.x === 3 &&
                L.turns.y === 3 &&
                L.crosses.length > 4 &&
                L.crosses.length < 7
            ) || (
                
                (notes.innerHTML = 'extra', true) &&
               
                (
                    L.turns.first = [
                        ...L.turns.xPts,
                        ...L.turns.yPts
                    ].sort((a, b) => a[2] - b[2])[0]
                ) &&
            
                (L = new LineObj([
                    L.coor[0],
                 ...L.coor.slice(
                    L.XXX.indexOf(L.turns.first[0]))
                ]).getAtAngl(
                    atan2(
                        L.coor[0][1] - L.turns.first[1],
                        L.coor[0][0] - L.turns.first[0]
                    )
                ).getTurns(), L.turns.xPts.length > 0) &&
                
                (
                   (L.turns.xPts[0][0] === L.coor[1][0] ||
                    L.turns.xPts.unshift(L.coor[1])),
                    L.reCoor = [
                     ...L.coor.slice(0,1),
                     ...L.turns.xPts
                         .map(v => [v[0], v[1]]),
                        L.coor.at(-1)
                    ]
                ) &&
                
                L.reCoor.length > 5 &&
                L.reCoor.length < 8 &&
                
               (L = new LineObj(L.reCoor, 0).getSelfXs()) &&
                
                /*
                (//{
                    lipGroup.innerHTML = '',
                    ratPath.setAttribute('d',L.makeSVG().svg),
                    L.crosses.forEach((p, i) => {
                        let lip = document.createElementNS(NS,
                            'ellipse');
                        lip.setAttribute('cx', p.x);
                        lip.setAttribute('cy', p.y);
                        lip.setAttribute('rx', 3);
                        lip.setAttribute('ry', 3);
                        lip.setAttribute('fill', '#fb0');
                        lipGroup.append(lip);
                    })
                    , true //}
                ) &&
                */
                
                
                L.crosses.length > 4 &&
                L.crosses.length < 7

            ))
            
        );
        
    },
    
    // u-shaped curve &#8746;
    you: d => {
        
        let L;
        
        return (
            
            d.length === 1 &&
            
           (d[0][0][0] < d[0].at(-1)[0] || d[0].reverse()) &&
            
           (L = linz(d)[0].getTurns()) &&
           
            L.turns.x === 0 &&
            L.turns.y === 1 &&
        
            L.wide > prefs.minSize &&
            L.wide < prefs.maxSize &&
            L.high > 0.1 * L.wide  &&
            
           (L.YYY[0] === L.yMin || L.YYY.at(-1) === L.yMin) &&
            
            abs(L.YYY[0] - L.YYY.at(-1)) < 0.2 * L.wide &&
            
            linz([
                L.coor.slice(0, L.turns.yPts[0][2] + 1),
                L.coor.slice(   L.turns.yPts[0][2])
            ]).every((LL, i) => LL.getAtOrig().org.xMin < -1)
            
        );

    },
  
    // werds reversed &#8767;
    rev: d => {
        
        let L;
        
        return (
            
            d.length === 1 &&
            
            (d[0].at(-1)[0] > d[0][0][0] || d[0].reverse()) &&
            
            (L = linz(d)[0].getTurns()) &&
            
            L.wide > prefs.minSize &&
            L.wide < 2 * prefs.maxSize &&
            L.high > prefs.minSize &&
            L.high < 2 * prefs.maxSize &&
            
            L.turns.x === 0 && L.turns.y === 2 &&
            
            L.turns.yPts.some(p => p[1] === L.yMin) &&
            L.turns.yPts.some(p => p[1] === L.yMax) &&
            
            L.turns.yPts[1][0] - L.turns.yPts[0][0]
            > 0.4 * L.wide &&
            
            abs(L.YYY[0]     - L.turns.yPts[0][1])
            > 0.3 * L.high &&
            
            abs(L.YYY.at(-1) - L.turns.yPts[1][1])
            > 0.3 * L.high
            
        );
        
    },
   
    // missing period &#9737;
    per: d => {
        
        let Dt, Cr;
        
        return (
            
            d.length === 2 &&
            
            ([Dt, Cr] = d.reduce((acc, c) => (acc[(
                
                c.length < 15 &&
                c.slice(1).every(p =>
                    abs(p[0] - c[0][0]) < 5 &&
                    abs(p[1] - c[0][1]) < 5
                )
                    
            )?0:1].push(new LineObj(c)),acc),[[],[]])) &&
            Dt.length === 1 && Cr.length === 1 &&
            
            ([Dt, Cr] = [Dt, Cr].map(v =>
                v[0].getTurns()
            )) &&
            
            abs(Cr.XXX[0] - Cr.XXX.at(-1)) < 0.3 * Cr.wide &&
            abs(Cr.YYY[0] - Cr.YYY.at(-1)) < 0.3 * Cr.high &&
            
            Cr.wide > prefs.minSize &&
            Cr.wide < 2 * prefs.maxSize &&
            Cr.high > prefs.minSize &&
            Cr.high < 2 * prefs.maxSize &&
            
            Cr.wide / Cr.high > 0.7 &&
            Cr.wide / Cr.high < 1.8 &&
            
            Cr.turns.x > 0 && Cr.turns.x < 3 &&
            Cr.turns.y > 0 && Cr.turns.y < 4 &&
            
            abs(((Cr.xMin + Cr.xMax) / 2) - Dt.XXX[0])
            < 0.2 * Cr.wide &&
            abs(((Cr.yMin + Cr.yMax) / 2) - Dt.YYY[0])
            < 0.2 * Cr.high &&
            
            true
            
        );
        
    },
     
    // backwards-P paragraph &#182;
    par: d => {
        
        let V, V1, V2, P, high;
        
        return (
            
            d.length === 3 &&
            clog('3 lines') &&
            
            ([V, P] = d.reduce((acc, c) => (acc[(
                
                c.slice(1).every(p =>
                    abs(p[0] - c[0][0]) < 20
                )
                    
            )?0:1].push(new LineObj(c)),acc),[[],[]])) &&
            V.length === 2 && P.length === 1 &&
            clog('2 verts') &&
            
            (
                [V1, V2, P] = [...V, P[0]].map(v =>
                    v.getTurns()
                ),
                high = max(V1.yMax, V2.yMax, P.yMax) -
                       min(V1.yMin, V2.yMin, P.yMin)
            ) &&
            clog('built') &&
            
            P.wide > prefs.minSize &&
            P.wide < prefs.maxSize &&
            high > prefs.minSize &&
            high < prefs.maxSize &&
            clog('size') &&
            
            abs(V1.yMin - V2.yMin) < 0.2 * high &&
            abs(V1.yMax - V2.yMax) < 0.2 * high &&
            clog('start|end') &&
            
            !hitt(V1, V2) &&
            clog('no overlap') &&
            
            abs(P.yMin - V1.yMin) < 0.2 * high &&
            clog('p top') &&
            
            abs(P.high - high / 2) < 0.3 * high &&
            clog('p height') &&
            
            P.XXX[0] - max(V1.xMax, V2.xMax) > 5 &&
            clog('p starts right') &&
            
            P.xMin < min(V1.xMin, V2.xMin) &&
            clog('p extends left') &&
        
            P.XXX[0]     > P.xMin &&
            P.XXX.at(-1) > P.xMin &&
            clog('p dir') &&
            
            P.getTurns().turns.y < 3 && P.turns.x < 2
            && clog('turns') &&
            true
        );
       
    },

    // x-marx the spot &#215;
    mrx: d => {
        
        let Up, Dn, pt;
        
        return (
            
            d.length === 2 &&
            
            ([Up, Dn] = linz(d).reduce((acc, LL) => (
                
                LL.getSlopes().getTurns()
                  .getAtOrig().org.getTurns(),
                
                acc[(
                    LL.slopes.all < -0.2 &&
                    LL.slopes.all > -4.0 ? 0 :
                    LL.slopes.all >  0.2 &&
                    LL.slopes.all <  4.0 ? 1 : 2
                )].push(LL),
                
                acc
                
            ),[[],[],[]])) &&
            
            Up.length === 1 && Dn.length === 1 &&
            (Up = Up[0], Dn = Dn[0]) &&
            
            [Up.org, Dn.org].every(LL =>
                (LL.turns.x < 2 && LL.turns.y === 0) ||
                LL.XXX.every(x => abs(x) < 5)
            ) &&
            
            max(Up.wide, Dn.wide) < 2 * prefs.maxSize &&
            max(Up.high, Dn.high) < 2 * prefs.maxSize &&
            min(Up.org.len, Dn.org.len) /
            max(Up.org.len, Dn.org.len) > 0.5 &&
            
            (pt = hitt(Up, Dn)) &&
            
            [Up.coor[0], Dn.coor[0]].every((c, i) => {
                let dis = sqrt(
                    (c[0] - pt[0]) ** 2 +
                    (c[1] - pt[1]) ** 2
                );
                return dis > 0.3 * [Up, Dn][i].org.len &&
                       dis < 0.7 * [Up, Dn][i].org.len
            })
            
        );
        
    },
    
    //}
    
    // heart-shaped box &#9825;
    hrt: d => {
        
        clearLips();
        ratPathD('');
        
        let Lf, Rt;
        
        if (d.length === 1) {
            
            let L = linz(d)[0];
            
            if (L.getSelfXs().crosses.length > 0) {
            
                if(L.crosses.length > 1) return false;
                
                L = new LineObj([
                    [L.crosses[0].x, L.crosses[0].y],
                  ...L.coor.slice(
                     L.crosses[0].id1 + 1,
                     L.crosses[0].id2 + 1),
                    [L.crosses[0].x, L.crosses[0].y]
                ]);
            
            }
            
            let yDex = (L.YYY.indexOf(L.yMax));
            
            if (yDex !== 0 && yDex !== L.coor.length -1) {
            
                L = new LineObj([
                    ...L.coor.slice(yDex),
                    ...L.coor.slice(0, yDex),
                ])
            
            }
           
            L.getTurns();
            
            if (L.turns.y < 3) return false;
            
            d = [
                L.coor.slice(0, L.turns.yPts[1][2] + 1),
                [
                 ...L.coor.slice(L.turns.yPts[1][2]),
                    L.coor[0]
                ]
            ];
            
        }
        
        return (//{
            
            d.length === 2 &&
            
            (
                [Lf, Rt] = linz(d)
                .map(LL =>
                    LL.coor[0][1] < LL.coor.at(-1)[1] ?
                    new LineObj(LL.coor.reverse()) : LL
                )
                .sort((a, b) => a.xMin - b.xMin)
            
            ) &&
            
            /*
            (ratPathD(Rt.makeSVG().svg+''+Lf.makeSVG().svg)
            ,true) &&
                        
            (makeLips([
                ...Lf.getTurns().turns.yPts,
                ...Rt.getTurns().turns.yPts
            ], '#fb0', 5), true) &&
            
            (makeLips([
                ...Lf.getTurns().turns.xPts,
                ...Rt.getTurns().turns.xPts
            ], '#09f'), true) &&
            //*/
            
            dist(Lf.coor[0], Rt.coor[0]) < 20 &&
            dist(Lf.coor.at(-1), Rt.coor.at(-1)) < 20 &&
            clog('near') &&
            
            min(Lf.wide, Rt.wide) / max(Lf.wide, Rt.wide)
            > 0.3 &&
            Rt.xMax - Lf.xMin < 2 * prefs.maxSize &&
            max(Lf.high, Rt.high) < 2 * prefs.maxSize &&
            clog('size') &&
            
            [Lf, Rt].every((LL, i) => {
                
                LL.getTurns();
                
                return (
                    LL.turns.y === 1 &&
                    LL.turns.yPts[0][1] < LL.coor.at(-1)[1] &&
                    (
                        LL.turns.x === 1 ||
                        (
                            LL.turns.x === 2 &&
                            LL.turns.xPts[1][2] >
                            LL.turns.yPts[0][2]
                        )
                    ) &&
                    
                    abs(
                        LL.turns.xPts[0][0] -
                        LL.turns.yPts[0][0]
                    ) > 0.1 * LL.wide &&
                    
                    sign(LL.coor[0][0] - LL.turns.xPts[0][0])
                    === [1, -1][i]
                    
                );
                
            }) &&
            clog('turns') &&
            
            abs(Lf.yMin - Rt.yMin) < 0.2 * Rt.high &&
            clog('top') &&
            
            /*
            (linz([
                Lf.coor.slice(
                    Lf.turns.xPts[0][2],
                    Lf.turns.yPts[0][2] + 1
                ),
                Lf.coor.slice(
                    Lf.turns.yPts[0][2]
                ),
                Rt.coor.slice(
                    Rt.turns.xPts[0][2],
                    Rt.turns.yPts[0][2] + 1
                ).reverse(),
                Rt.coor.slice(
                    Rt.turns.yPts[0][2]
                ).reverse()
            ]).every((LL, i) => {
                
                let o = LL.getAtOrig().org.getTurns();
                
                return (
                    o.turns.x > 0 &&
                    o.turns.x < 4 &&
                    o.xMin == 0
                );
                
            })) &&
            clog('curve') &&
            //*/
            
            true
            
        );//}
        
    },

    //{
    
    // + sign &#43;
    pls: d => {
        
        let Vt, Hz, pt;
        
        return (
            
            d.length === 2 &&
            
            ([Vt, Hz] = linz(d).reduce((acc, LL) => {
            
                LL.getTurns();
            
                if (
                    LL.high > 20 &&
                    LL.high < 2 * prefs.maxSize &&
                    LL.wide < 0.2 * LL.high &&
                    LL.turns.y === 0 &&
                    LL.turns.x < 2
                ) {
                    acc[0].push(LL)
                }
                else if (
                    LL.wide > 20 &&
                    LL.wide < 2 * prefs.maxSize &&
                    LL.high < 0.2 * LL.wide &&
                    LL.turns.x === 0 &&
                    LL.turns.y < 2
                ) {
                    acc[1].push(LL)
                }
                return acc;
            },[[],[]])) &&
            
            Vt.length === 1 && Hz.length === 1 &&
            (Vt = Vt[0], Hz = Hz[0]) &&
            
            min(Vt.high, Hz.wide) / max(Vt.high, Hz.wide)
            > 0.45 &&
            
            (pt = hitt(Vt, Hz)) &&
            
            (Vt.per = abs(Vt.YYY[0] - pt[1]) / Vt.high) &&
            0.3 < Vt.per && Vt.per < 0.7 &&
            (Hz.per = abs(Hz.XXX[0] - pt[0]) / Hz.wide) &&
            0.3 < Hz.per && Hz.per < 0.7
            
        );
        
    }

    //}
};

//}

// animated cross check {
const crossCheck = new function () {

    let iCount = 1;
    let jCount = 3;
    let checkLine = [];
    let interPts = [];
    let loop = null;

    const check = () => {

        if (iCount < checkLine.coor.length - 2) {

            ratLine.setAttribute('d',
                'M' + checkLine.coor[iCount].join(' ') +
                'L' + checkLine.coor[iCount - 1].join(' ')
            );

            if (jCount < checkLine.coor.length) {

                ratPath.setAttribute('d',
                    'M' + checkLine.coor[jCount].join(' ') +
                    'L' + checkLine.coor[jCount - 1].join(' ')
                );

                let pt = crss([
                    checkLine.coor[iCount - 1],
                    checkLine.coor[iCount],
                    checkLine.coor[jCount - 1],
                    checkLine.coor[jCount]
                ]);

                if (pt) {
                    log('got one');
                    interPts.push({ x: pt[0], y: pt[1], i: iCount, j: jCount });
                }

                jCount++;
                loop = setTimeout(check, 500);

            }
            else {

                iCount++;
                jCount = iCount + 2;
                loop = setTimeout(check, 0);

            }

        }
        else {
            loop = null;
            ratLine.setAttribute('d', '');
            ratPath.setAttribute('d', '');
            interPts.forEach(p => {
                ratPath.setAttribute('d',
                    ratPath.getAttribute('d') +
                    'M' + checkLine.coor[p.i].join(' ') +
                    'L' + checkLine.coor[p.i - 1].join(' ') +
                    'M' + checkLine.coor[p.j].join(' ') +
                    'L' + checkLine.coor[p.j - 1].join(' ')
                );

                let lip = document.createElementNS(NS, 'ellipse');
                lip.setAttribute('cx', p.x);
                lip.setAttribute('cy', p.y);
                lip.setAttribute('rx', 5);
                lip.setAttribute('ry', 5);
                lip.setAttribute('fill', '#fb0');
                lipGroup.append(lip);
            });
        }

    };

    this.test = d => {
        iCount = 1;
        jCount = 3;
        interPts = [];
        checkLine = linz(d)[0];
        lipGroup.innerHTML = '';
        loop = clearTimeout(loop);
        check();
    };

}();

// }

// ellipse and line testing {

const ratLineD = d => ratLine.setAttribute('d', d);
const ratPathD = d => ratPath.setAttribute('d', d);
const makeLips = (d, col='#fb0', rad=3) => {
    d.forEach(c => {
        let lip = document.createElementNS(NS, 'ellipse');
        lip.setAttribute('cx', c[0] || c.x || 0);
        lip.setAttribute('cy', c[1] || c.y || 0);
        lip.setAttribute('rx', rad);
        lip.setAttribute('ry', rad);
        lip.setAttribute('fill', col);
        lipGroup.append(lip);
    });
};
const clearLips = () => lipGroup.innerHTML = '';
    
//}

// app methods {

const linz = (d, t=true) => {
    
     return d.map(D => new LineObj(D, t));
        
};

const hitt = (a, b) => {
    
    let p = [];
    
    a.coor.slice(1).some((ci, i) =>
    b.coor.slice(1).some((cj, j) =>
        p = crss([a.coor[i], ci, b.coor[j], cj])
    ));
    
    return p;
    
};

const hitz = (a, b) => {
    
    let h = [];
    
    a.coor.slice(1).forEach((ci, i) =>
    b.coor.slice(1).forEach((cj, j) => {
        let p = crss([a.coor[i], ci, b.coor[j], cj]);
        if (p) h.push({
            x: p[0],
            y: p[1],
            id1: i,
            id2: j
        });
    }));
    
    return h;
    
};

const dist = (a, b) => {
    
    return sqrt(
        (a[1] - b[1]) ** 2 +
        (a[0] - b[0]) ** 2
    )
    
};

const crss = h => {

    if (h.length < 4) return false;

    //* foxxy method *//
    let [a, b, c, d, p, q, r, s] = [...h.flat()];

    let det = (c - a) * (s - q) - (r - p) * (d - b), gam, lam;
    
    if (det === 0) return false;
    
    lam = ((s - q) * (r - a) + (p - r) * (s - b)) / det;
    gam = ((b - d) * (r - a) + (c - a) * (s - b)) / det;
    
    return ((0 < lam && lam < 1) && (0 < gam && gam < 1)) ?
    [a + lam * (c - a), b + lam * (d - b)] : false;

};

const mark = d => {

    const coords = d.match(/[\d\.-]+/g).map(v => Number(v));

    const XXX = coords.filter((_, i) => i % 2 === 0);
    const YYY = coords.filter((_, i) => i % 2 === 1);

    const min = {
        x: min(...XXX),
        y: min(...YYY)
    };

    const max = {
        x: max(...XXX),
        y: max(...YYY)
    };

    const diff = {
        x: max.x - min.x,
        y: max.y - min.y
    };

    const most = max(diff.x, diff.y);

    const scale = 50 / most;

    const trans = {
        x: -1 * min.x + most / 2 - diff.x / 2,
        y: -1 * min.y + most / 2 - diff.y / 2
    }

    return `scale(${scale}) translate(${trans.x}px, ${trans.y}px) `;

};

const draw = e => {

    e.preventDefault();
    e.stopPropagation();
    
    if (
        e.pageX === coordList.at(-1).at(-1).x &&
        e.pageY === coordList.at(-1).at(-1).y
    ) return;
    
    coordList.at(-1).push(new Point(e.pageX, e.pageY));
    
    let pts = [
        coordList.at(-1).at(-1),
        coordList.at(-1).at(-2)
    ].sort((a, b) => a.y - b.y);

    const path = svg.lastChild;
    
    //if (!path) { return; }
    
    if(pts[0].y === pts[1].y) {
        pts.sort((a, b) => b.x - a.x);
        path.setAttribute('d',
        (path.getAttribute('d')||'') + (
            
            'M' + pts[0].RtoL +
            'L' + pts[1].LtoR + 'Z'
            
        ));
    } else {
    
        path.setAttribute('d',
            (path.getAttribute('d') || '') + (
    
                (
                    prefs.penTheta <=
                    atan2(
                        (pts[0].y - pts[1].y),
                        (pts[0].x - pts[1].x)
                    )
                ) ? (
    
                    'M' + pts[0].RtoL +
                    'L' + pts[1].LtoR + 'Z'
    
                ) : (
    
                    'M' + pts[0].LtoR +
                    'L' + pts[1].RtoL + 'Z'
    
                )
    
        ));
    }

};
    
const down = e => {
    
    //e.preventDefault();
    e.target.releasePointerCapture(e.pointerId);

    notes.innerHTML = '&nbsp;';

    if (e.pageX > 0.8 * document.body.offsetWidth) {
        waiting = clearTimeout(waiting);
        uppp(e);
        return;
    }

    for (let i in this) {
        this[i].completed || this[i].activate(true);
    }

    if (waiting) {
        
        waiting = clearTimeout(waiting);
        coordList.push([]);
        
    } else {
    
        let path = document.createElementNS(NS, 'path');
        path.setAttribute('fill-rule', 'nonzero');
    
        coordList = [[]];
        svg.appendChild(path);
        
    }

    coordList.at(-1).push(
        (new Point(e.pageX, e.pageY))
    );

    addLiz('pointermove', draw, { passive: false });

};

const uppp = e => {
    
    //e.preventDefault();
    //e.stopPropagation();
    
    let path = svg.lastChild;
    
    if (!path) return;
    
    remLiz('pointermove', draw, {passive:false});

    for (let i in this) {
        if (!this[i].completed) {
            this[i].activate(false);
        }
    }

    waiting = setTimeout(exam, prefs.pause);

};

const exam = _ => {

    waiting = false;
    
    const path = svg.lastChild;
    
    if (!path) {
        complist = [];
        return;
    }
    
    const d = coordList.map(c => c.map(p => [p.x, p.y]));
    
    for (let CZ of compList) {
        
        if (CZ.test(d)) {
        
            CZ.divS.setProperty('text-decoration', 'line-through');
            CZ.box.classList.add('completed');
            CZ.check.style.opacity = 1;
        
            if (prefs.useDrawnMark) {
        
                CZ.check.style.d = 'path("' + d + '")';
                CZ.check.style.transform = mark(d);
        
            }
        
        } else {
            CZ.activate(true);
        }
        
        CZ.reprep();
    }
    
    compList = [];
    coordList = [];

    path.style.opacity = 0;
    setTimeout(() => svg.removeChild(path), 500);

};

//}

// create objects {

document.querySelectorAll('[data-czech]').forEach((CZ, i) =>
    this[i] = new Tczech(CZ)
);

//}

// add lizzers {

addLiz('pointerdown',   down, { passive: false });
addLiz('pointerup',     uppp, { passive: false });
addLiz('pointercancel', uppp, { passive: false });

addLiz('touchstart', e => {
    e.stopPropagation(); e.preventDefault();
    return false;
});

addLiz('touchmove', e => {
    e.stopPropagation(); e.preventDefault();
    return false;
});

addLiz('touchcancel', e => {
    e.stopPropagation(); e.preventDefault();
    return false;
});

//}

}();


</script>

</html>
  
